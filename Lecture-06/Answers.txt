Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

cd является shell builtin, т.е. встроенной функцией шелла. В принципе логично, что оболочка должна иметь функционал навигации по файловой системе. Нет смысла плодить процессы для банального перехода в другую папку.



Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

$ grep -c (либо --count) <some_string> <some_file>



Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

systemd



Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

$ ls -l /root 2>/dev/pts/1



Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

$ grep 42 < somefile > results
(Немного бессмысленный пример, но ничего более умного в голову не пришло..)



Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Насчет именно графического режима не уверен(ибо его нет в вируалке вагранта), но из ssh-сессии с PTY получилось вывести на TTY.



Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Создастся новый дескриптор 5, который будет перенаправляться в stdout. При выполнении команды получим вывод netology на экране, т.к. это stdout.



Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

$ find / lib 3>&1 1>&2 2>&3 | grep -c -i "denied"



Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Выводит:
USER=vagrantLOGNAME=vagrantHOME=/home/vagrantPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/gamesSHELL=/bin/bashTERM=xterm-256colorXDG_SESSION_ID=1XDG_RUNTIME_DIR=/run/user/1000DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/busXDG_SESSION_TYPE=ttyXDG_SESSION_CLASS=userMOTD_SHOWN=pamLANG=en_US.UTF-8LANGUAGE=en_US:SSH_CLIENT=10.0.2.2 51146 22SSH_CONNECTION=10.0.2.2 51146 10.0.2.15 22SSH_TTY=/dev/pts/0

Может я не правильно понял второй вопрос, но можно сделать вот так:
$ ps e -ww -p $$ -o args --no-headers | cut -d " " -f 2- | sed 's/ //g'



Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

cmdline - полная командная строка процесса
exe - символическая ссылка на исполняемый файл



Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

SSE 4.2



При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.

По-умолчанию для выполнения команды через SSH-подключение TTY не выделяется. Для того, чтобы принудительно выделить TTY можно использовать опцию -tt:
$ ssh -tt localhost 'tty'
vagrant@localhost's password:
/dev/pts/2
Connection to localhost closed.
