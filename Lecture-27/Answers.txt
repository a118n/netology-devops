Задача 1
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:
напишите список операций, которые вы будете производить для остановки запроса пользователя
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

db.currentOp({"secs_running": {$gte: 5}})
db.killOp(<opId>)
Можно выставить таймаут maxTimeMS(), по которому операции будут прерываться автоматически.



Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.
Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.
При масштабировании сервиса до N реплик вы увидели, что:
сначала рост отношения записанных значений к истекшим
Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

Видимо вся память забилась истекшими ключами, но еще не удаленными. Редис заблокировался, чтобы вывести из БД удаленные ключи и снизить их количество менее 25%. С ссылки:
if the database has many many keys expiring in the same second, and these make up at least 25% of the current population of keys with an expire set, Redis can block in order to get the percentage of keys already expired below 25%.



Задача 3
Перед выполнением задания познакомьтесь с документацией по Common Mysql errors.
Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?
Какие пути решения данной проблемы вы можете предложить?

Локализовать через Slow Log. В первую очередь я бы проверил/выставил параметры net_read_timeout, connect_timeout, max_allowed_packet в my.cnf. Сервер явно не справляется с большим количеством запросов и дропает соединения. Ну и на всякий случай проверить RAM, inodes, disk space, etc.



Задача 4
Перед выполнением задания ознакомтесь со статьей Common PostgreSQL errors из блога Percona.
Вы решили перевезти гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
postmaster invoked oom-killer
Как вы думаете, что происходит?
Как бы вы решили данную проблему?


Если запускается oom-killer, значит закончилась память на сервере. Самый простой вариант - добавить оперативки.
Если по каким-то причинам это не возможно, нужно тюнить конфиг postgresql:
work_mem
shared_buffers
effective_cache_size
maintenance_work_mem

Можно еще снизить OOM Score процесса postgresql, используя директиву OOMScoreAdjust=-1000 в блоке [Service] systemd-юнита, что должно снизить вероятнось убивания процесса системой.
