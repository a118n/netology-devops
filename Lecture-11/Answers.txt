Узнайте о том, сколько действительно независимых (не пересекающихся) каналов есть в разделяемой среде WiFi при работе на 2.4 ГГц. Стандарты с полосой 5 ГГц более актуальны, но регламенты на 5 ГГц существенно различаются в разных странах, а так же не раз обновлялись. В качестве дополнительного вопроса вне зачета, попробуйте найти актуалый ответ и на этот вопрос.

2.4 GHz - три. Если доступен 14 канал, тогда четыре.
5 GHz - 24.



Адрес канального уровня – MAC адрес – это 6 байт, первые 3 из которых называются OUI – Organizationally Unique Identifier или уникальный идентификатор организации. Какому производителю принадлежит MAC 38:f9:d3:55:55:79?

Apple, Inc.



Каким будет payload TCP сегмента, если Ethernet MTU задан в 9001 байт, размер заголовков IPv4 – 20 байт, а TCP – 32 байта?

8949 байт.



Может ли во флагах TCP одновременно быть установлены флаги SYN и FIN при штатном режиме работы сети? Почему да или нет?

Нет.
An application that sends a SYN and FIN bit at the same time is considered an illegal packet, which is used by hackers to provide a Denial of Service (DoS) on systems.
This is indicative that a reconnaissance sweep of your network may be in progress. The use of this type of packet indicates an attempt to conceal the sweep. This may be the prelude to a more serious attack. This should never occur in legitimate traffic. The source of this packet should be shunned.



Почему в State присутствует только UNCONN, и может ли там присутствовать, например, TIME-WAIT?

Флаг -u в команде выводит только UDP-сокеты, а они по сути stateless, тоесть time-wait (как и остальных статусов) у них не бывает, как у tcp. Они могут быть либо UNCONN, либо ESTAB (тоесть сокет соединен\нет).



Обладая знаниями о том, как штатным образом завершается соединение (FIN от инициатора, FIN-ACK от ответчика, ACK от инициатора), опишите в каких состояниях будет находиться TCP соединение в каждый момент времени на клиенте и на сервере при завершении. Схема переходов состояния соединения вам в этом поможет.

Инициатор [I] посылает FIN, переходит в состояние FIN_WAIT_1. Получатель [R] получает FIN, посылает ACK, переходит в CLOSE_WAIT. [I] получает ACK, переходит в FIN_WAIT_2. [R] посылает FIN, переходит в LAST_ACK. [I] получает FIN, посылает ACK, переходит в TIME_WAIT. [R] получает ACK, переходит в CLOSED. После таймаута [I] переходит в CLOSED.



TCP порт – 16 битное число. Предположим, 2 находящихся в одной сети хоста устанавливают между собой соединения. Каким будет теоретическое максимальное число соединений, ограниченное только лишь параметрами L4, которое параллельно может установить клиент с одного IP адреса к серверу с одним IP адресом? Сколько соединений сможет обслужить сервер от одного клиента? А если клиентов больше одного?

4,294,836,225 (65535 * 65535) максимальных соединений (порт 0 не учитываем). Сервер соответсвенно сможет обслужить столько же от одного клиента. Если клиентов больше, то умножаем на кол-во уникальных ip адресов.



Может ли сложиться ситуация, при которой большое число соединений TCP на хосте находятся в состоянии TIME-WAIT? Если да, то является ли она хорошей или плохой? Подкрепите свой ответ пояснением той или иной оценки.

Если делать очень много коротких соединений (или просто DDoS-ить), то такая ситуация может сложиться. Можно упереться в отсутствие свободных портов на сервере. Это приведет к тому, что установить новые соединения не получится. Плюс, каждый такой сокет будет занимать место в памяти ядра. Такая ситуация явно скорее плохая, нежели хорошая.
Можно включить использование таких сокетов для новых соединений (таким образом теоретически решив проблему 1), установив net.ipv4.tcp_tw_reuse = 1.
Интересно (вроде раньше это был бинарный параметр):
# sysctl -a | grep tcp_tw_reuse
net.ipv4.tcp_tw_reuse = 2
Что выводит нас на https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=79e9fed460385a3d8ba0b5782e9e74405cb199b1.
Т.е. реюз сокетов по-умолчанию используется для loopback-интерфейсов.


Чем особенно плоха фрагментация UDP относительно фрагментации TCP?

В UDP нет поддержки повторной отправки, нумерации сегментов, переупорядочивания сегментов. При потере хотя бы одного фрагмента вся датаграмма будет считаться потерянной (тогда как TCP может повторно выслать потерянные фрагменты).



Если бы вы строили систему удаленного сбора логов, то есть систему, в которой несколько хостов отправяют на центральный узел генерируемые приложениями логи (предположим, что логи – текстовая информация), какой протокол транспортного уровня вы выбрали бы и почему? Проверьте ваше предположение самостоятельно, узнав о стандартном протоколе syslog.

UDP, т.к. в локальной сети будет быстрее. Нет оверхэда. Опять же проще и быстрее повторно выслать датаграмму при потере. При отсылке большого кол-ва логов, важнее скорость и производительность. А механизм контроля целостности опять же можно имплементировать на более высоком уровне, чтобы не грузить сеть. Можно сделать например отправку супер-критичных логов по TCP, всех остальных по UDP.



Сколько портов TCP находится в состоянии прослушивания на вашей виртуальной машине с Ubuntu, и каким процессам они принадлежат?

root@ubuntu-20:~# ss -tlpn
State          Recv-Q         Send-Q                 Local Address:Port                 Peer Address:Port         Process
LISTEN         0              4096                   127.0.0.53%lo:53                        0.0.0.0:*             users:(("systemd-resolve",pid=777,fd=13))
LISTEN         0              128                          0.0.0.0:22                        0.0.0.0:*             users:(("sshd",pid=1012,fd=3))
LISTEN         0              128                             [::]:22                           [::]:*             users:(("sshd",pid=1012,fd=4))

53 порт - dns systemd-resolved
22 порт в 2 версиях (ipv4\ipv6) - sshd



Какой ключ нужно добавить в tcpdump, чтобы он начал выводить не только заголовки, но и содержимое фреймов в текстовом виде? А в текстовом и шестнадцатиричном?

-A     Print each packet (minus its link level header) in ASCII.
-X     When parsing and printing, in addition to printing the headers of each packet, print the data of each packet (minus its link level header) in  hex
              and ASCII.  This is very handy for analysing new protocols.
-XX    When  parsing and printing, in addition to printing the headers of each packet, print the data of each packet, including its link level header, in
              hex and ASCII.



Попробуйте собрать дамп трафика с помощью tcpdump на основном интерфейсе вашей виртуальной машины и посмотреть его через tshark или Wireshark (можно ограничить число пакетов -c 100). Встретились ли вам какие-то установленные флаги Internet Protocol (не флаги TCP, а флаги IP)? Узнайте, какие флаги бывают. Как на самом деле называется стандарт Ethernet, фреймы которого попали в ваш дамп? Можно ли где-то в дампе увидеть OUI?

Ethernet II, Src: Microsof_01:41:0e (00:15:5d:01:41:0e), Dst: Microsof_a4:e0:17 (00:15:5d:a4:e0:17)
Стандарт Ethernet II. OUI тоже видны.

 Flags: 0x4000, Don't fragment
        0... .... .... .... = Reserved bit: Not set
        .1.. .... .... .... = Don't fragment: Set
        ..0. .... .... .... = More fragments: Not set
По дефолту выставляется флаг don't fragment.
